<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CANDY POP BLAST</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            font-family: 'Fredoka One', cursive;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: white;
        }

        /* „Çπ„Çø„Éº„Éà„Ç∑„Éº„Ç±„É≥„Çπ„Ç™„Éº„Éê„Éº„É¨„Ç§ */
        #start-sequence-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 234, 167, 1), rgba(129, 236, 236, 1));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #start-icon {
            width: 80%;
            max-width: 400px;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        #start-countdown {
            font-size: 80px;
            color: #fff;
            text-shadow: 4px 4px 0 #ff7675, 8px 8px 0 #74b9ff;
            font-weight: bold;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #ffeaa7;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .top-info {
            pointer-events: none;
        }

        .score {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #level-display,
        #power-display {
            color: #f1c40f;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-top: 5px;
        }

        #power-display {
            color: #e74c3c;
        }

        /* „Éú„Çø„É≥È°û */
        button.action-btn {
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Fredoka One', cursive;
            background: #ff7675;
            /* Pastel Red */
            color: white;
            border: 4px solid #fff;
            border-radius: 50px;
            /* Rounded */
            cursor: pointer;
            box-shadow: 0 6px 0 #d63031, 0 10px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
            margin: 15px;
            pointer-events: auto;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button.action-btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        button.sub-btn {
            background: #74b9ff;
            /* Pastel Blue */
            box-shadow: 0 6px 0 #0984e3, 0 10px 10px rgba(0, 0, 0, 0.2);
            font-size: 20px;
            padding: 12px 24px;
        }

        /* ÁîªÈù¢„Ç≥„É≥„ÉÜ„Éä */
        #start-screen,
        #game-over-screen,
        #pause-screen,
        #practice-config-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 234, 167, 0.95), rgba(129, 236, 236, 0.95));
            /* Pastel Gradient */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
        }

        /* „Éù„Éº„Ç∫„Éú„Çø„É≥ */
        #pauseButton {
            pointer-events: auto;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 20;
        }

        /* „Éó„É©„ÇØ„ÉÜ„Ç£„ÇπÁµÇ‰∫Ü„Éú„Çø„É≥ */
        #quitPracticeButton {
            pointer-events: auto;
            position: absolute;
            top: 20px;
            right: 60px;
            /* Adjusted to make room for mute button */
            padding: 8px 16px;
            background: #e74c3c;
            border: 1px solid white;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            z-index: 20;
        }

        /* „Éü„É•„Éº„Éà„Éú„Çø„É≥ */
        #muteButton {
            pointer-events: auto;
            position: absolute;
            top: 20px;
            right: 20px;
            width: 36px;
            height: 36px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 30;
        }

        /* „Éó„É©„ÇØ„ÉÜ„Ç£„ÇπË®≠ÂÆöÁîªÈù¢„ÅÆ„Çπ„Çø„Ç§„É´ */
        .config-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 80%;
            max-width: 400px;
            margin: 10px 0;
            font-size: 18px;
        }

        .config-label {
            flex: 1;
            text-align: left;
        }

        .config-value {
            flex: 1;
            text-align: right;
        }

        .toggle-btn {
            background: #a29bfe;
            /* Pastel Purple */
            border: 1px solid #7f8c8d;
            color: white;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            min-width: 100px;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            font-size: 16px;
            text-align: center;
            border-radius: 4px;
            border: none;
        }

        h1 {
            font-size: 50px;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 4px 4px 0 #ff7675, 8px 8px 0 #74b9ff;
            /* Pop Shadow */
            letter-spacing: 2px;
            transform: rotate(-3deg);
        }

        h2 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #3498db;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#e74c3c">
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW registered!', reg))
                    .catch(err => console.log('SW registration failed: ', err));
            });
        }
    </script>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="top-info">
            <div class="score">SCORE: <span id="scoreDisplay">0</span></div>
            <div id="level-display">STAGE: <span id="stageDisplay">1</span></div>
            <div id="power-display">POWER: <span id="powerValueDisplay">1</span></div>
        </div>
        <div id="pauseButton">||</div>
        <div id="quitPracticeButton" class="hidden">ÁµÇ„Çè„Çã</div>
        <div id="muteButton">üîä</div>
    </div>

    <!-- „Çπ„Çø„Éº„Éà„Ç∑„Éº„Ç±„É≥„ÇπÔºàÂàùÊúüÈùûË°®Á§∫Ôºâ -->
    <div id="start-sequence-overlay" class="hidden">
        <img id="start-icon" src="icon-512.png" alt="App Icon">
        <div id="start-countdown">3</div>
    </div>

    <!-- „Çπ„Çø„Éº„ÉàÁîªÈù¢ -->
    <div id="start-screen">
        <h1>CANDY POP<br>BLAST</h1>
        <p style="color: #636e72; font-weight: bold;">Tap / Click to Play!</p>
        <button id="startButton" class="action-btn">START CLASH!</button>
        <button id="practiceButton" class="action-btn sub-btn">PRACTICE</button>
    </div>

    <!-- „Éó„É©„ÇØ„ÉÜ„Ç£„ÇπË®≠ÂÆöÁîªÈù¢ -->
    <div id="practice-config-screen" class="hidden">
        <h2>Practice Setup</h2>

        <div class="config-row">
            <span class="config-label">„Çπ„ÉÜ„Éº„Ç∏</span>
            <div class="config-value">
                <button id="confStageBtn" class="toggle-btn">Ê£ÆÊûó</button>
            </div>
        </div>

        <div class="config-row">
            <span class="config-label">Êïµ„ÅÆËÄê‰πÖÂäõ</span>
            <div class="config-value">
                <input type="number" id="confEnemyHp" value="1" min="1">
            </div>
        </div>

        <div class="config-row">
            <span class="config-label">Ëá™Ê©ü„ÅÆÂºæÂ®ÅÂäõ</span>
            <div class="config-value">
                <input type="number" id="confPlayerPower" value="1" min="1" step="0.1">
            </div>
        </div>

        <div class="config-row">
            <span class="config-label">„Ç¢„Ç§„ÉÜ„É†</span>
            <div class="config-value">
                <button id="confItemBtn" class="toggle-btn">„Å™„Åó</button>
            </div>
        </div>

        <div style="margin-top: 30px; display: flex; gap: 20px;">
            <button id="backToTitleBtn" class="action-btn sub-btn">Êàª„Çã</button>
            <button id="startPracticeBtn" class="action-btn">Ê±∫ÂÆö</button>
        </div>
    </div>

    <div id="pause-screen" class="hidden">
        <h1>PAUSED</h1>
        <button id="resumeButton" class="action-btn">ÂÜçÈñã„Åô„Çã</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>GAME OVER</h1>
        <p>ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: <span id="finalScore">0</span><br>Âà∞ÈÅî„Çπ„ÉÜ„Éº„Ç∏: <span id="finalStage">1</span></p>
        <button id="restartButton" class="action-btn">ÂÜçÂá∫ÊíÉ</button>
    </div>

    <script>
        // --- Èü≥Â£∞ÁÆ°ÁêÜ ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.isMuted = false;
            }
            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.isMuted) {
                    if (this.ctx) this.ctx.suspend();
                    if (this.bgmAudio) this.bgmAudio.muted = true;
                    document.getElementById('muteButton').innerText = 'üîá';
                } else {
                    if (this.ctx) this.ctx.resume();
                    if (this.bgmAudio) this.bgmAudio.muted = false;
                    document.getElementById('muteButton').innerText = 'üîä';
                }
            }
            init() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                } else if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }
            playShoot() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.1);
            }
            playExplosion() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start(t);
            }
            playPowerUp() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.linearRampToValueAtTime(800, t + 0.3);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.3);
            }

            // --- BGM (Updated to use sol1.mp3) ---
            playBGM() {
                if (this.bgmAudio) {
                    if (this.bgmAudio.paused) this.bgmAudio.play().catch(e => console.log(e));
                    return;
                }

                this.bgmAudio = new Audio('sol1.mp3');
                this.bgmAudio.loop = true;
                this.bgmAudio.volume = 0.2; // Lowered significantly as requested

                // Mute check
                if (this.isMuted) this.bgmAudio.muted = true;

                this.bgmAudio.play().catch(e => console.log("Audio play failed:", e));
            }

            stopBGM() {
                if (this.bgmAudio) {
                    this.bgmAudio.pause();
                    this.bgmAudio.currentTime = 0;
                }
            }

            // --- Countdown SFX ---
            playCountdown(isGo = false) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                if (isGo) {
                    // "GO!" Sound (Higher pitch, longer)
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(880, t); // A5
                    osc.frequency.exponentialRampToValueAtTime(1760, t + 0.1); // Slide up to A6
                    gain.gain.setValueAtTime(0.3, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
                    osc.start(t);
                    osc.stop(t + 0.6);
                } else {
                    // "3, 2, 1" Sound (Short beep)
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, t); // A4
                    gain.gain.setValueAtTime(0.2, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                    osc.start(t);
                    osc.stop(t + 0.1);
                }

                osc.connect(gain);
                gain.connect(this.ctx.destination);
            }
        }
        const sound = new SoundManager();

        // --- Ë®≠ÂÆö ---
        const CONFIG = {
            playerSpeed: 0.8,
            bulletSpeed: 15,
            enemySpeedMin: 0.4,
            enemySpeedMax: 1.0,
            spawnRate: 10,
            particleCount: 25,
            drag: 0.98,
            gravity: 0.1,
            bossScoreThreshold: 100000,
            baseBossHp: 200,
            bossScore: 50000,
            bgPatternHeight: 800
        };

        // --- „ÉØ„Éº„ÉóÈÅ∑ÁßªÁî®Â§âÊï∞ ---
        let isWarping = false;
        let warpTimer = 0;
        let warpParticles = [];

        // --- DOMË¶ÅÁ¥† ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // UI
        const scoreDisplay = document.getElementById('scoreDisplay');
        const stageDisplay = document.getElementById('stageDisplay');
        const powerValueDisplay = document.getElementById('powerValueDisplay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalStageDisplay = document.getElementById('finalStage');
        // „Çπ„ÇØ„É™„Éº„É≥
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const practiceConfigScreen = document.getElementById('practice-config-screen');
        // „Éú„Çø„É≥
        const startButton = document.getElementById('startButton');
        const practiceButton = document.getElementById('practiceButton');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const resumeButton = document.getElementById('resumeButton');
        const quitPracticeButton = document.getElementById('quitPracticeButton');
        const muteButton = document.getElementById('muteButton');
        // Ë®≠ÂÆö„Éú„Çø„É≥
        const confStageBtn = document.getElementById('confStageBtn');
        const confEnemyHpInput = document.getElementById('confEnemyHp');
        const confPlayerPowerInput = document.getElementById('confPlayerPower');
        const confItemBtn = document.getElementById('confItemBtn');
        const startPracticeBtn = document.getElementById('startPracticeBtn');
        const backToTitleBtn = document.getElementById('backToTitleBtn');

        // --- „Ç≤„Éº„É†Áä∂ÊÖãÂ§âÊï∞ ---
        let gameRunning = false;
        let isPaused = false;
        let isPracticeMode = false;
        let score = 0;
        let frameCount = 0;
        let mouseX = 0;
        let isFiring = false;
        let nextBossScore = CONFIG.bossScoreThreshold;
        let bossActive = false;
        let bgOffset = 0;
        let stageLevel = 1;
        let enemyHpMultiplier = 1;
        let enemySpawnCounter = 0;
        let gameMode = 'normal'; // 'normal' or 'practice'
        let animationId = null; // For requestAnimationFrame
        let bossSpawned = false;
        let stageTimer = 0;


        // „Éó„É©„ÇØ„ÉÜ„Ç£„ÇπÁî®Ë®≠ÂÆö
        let practiceSettings = {
            stage: 'forest', // forest, road, city
            enemyHp: 1,
            playerPower: 1,
            items: false
        };

        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let items = [];
        let boss = null;

        let bgDirtCanvas, bgRoadCanvas, bgCityCanvas;

        // --- ÂàùÊúüÂåñ„Éª„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº ---
        function resize() {
            canvas.width = Math.min(window.innerWidth, 600);
            canvas.height = window.innerHeight;
            if (player) player.y = canvas.height - 100;
            bgDirtCanvas = createBgPattern('dirt');
            bgRoadCanvas = createBgPattern('road');
            bgCityCanvas = createBgPattern('city');
        }
        window.addEventListener('resize', resize);

        function updateInput(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            mouseX = clientX - rect.left;
            if (mouseX < 0) mouseX = 0;
            if (mouseX > canvas.width) mouseX = canvas.width;
        }

        canvas.addEventListener('mousemove', updateInput);
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); updateInput(e); }, { passive: false });

        const startFiring = (e) => {
            if (e.target.closest('#pauseButton') || e.target.closest('#quitPracticeButton')) return;
            isFiring = true;
            updateInput(e);
        };
        canvas.addEventListener('mousedown', startFiring);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startFiring(e); }, { passive: false });

        const stopFiring = (e) => {
            if (e.type === 'touchend' || e.type === 'touchcancel') e.preventDefault();
            isFiring = false;
        };
        canvas.addEventListener('mouseup', stopFiring);
        canvas.addEventListener('mouseleave', stopFiring);
        canvas.addEventListener('touchend', stopFiring);
        canvas.addEventListener('touchcancel', stopFiring);

        // --- ËÉåÊôØÁîüÊàê ---
        function createBgPattern(type) {
            const c = document.createElement('canvas');
            c.width = Math.min(window.innerWidth, 600);
            c.height = CONFIG.bgPatternHeight;
            const cx = c.getContext('2d');

            cx.fillStyle = (type === 'road' || type === 'city') ? '#dfe6e9' : '#ffeaa7'; /* Pastel Road / Dirt */
            cx.fillRect(0, 0, c.width, c.height);

            if (type === 'road' || type === 'city') {
                cx.strokeStyle = '#fdcb6e'; /* Pastel Yellow Lane */
                cx.lineWidth = 10;
                cx.setLineDash([40, 40]);
                cx.beginPath();
                cx.moveTo(c.width / 2, 0);
                cx.lineTo(c.width / 2, c.height);
                cx.stroke();
            }

            if (type === 'city') {
                const buildColors = ['#81ecec', '#fab1a0', '#a29bfe', '#dfe6e9']; /* Pastel Buildings */
                const drawBuildings = (startX, isLeft) => {
                    let y = 0;
                    while (y < c.height) {
                        const h = Math.random() * 50 + 40;
                        const w = Math.random() * 30 + 30;
                        const color = buildColors[Math.floor(Math.random() * buildColors.length)];
                        const x = isLeft ? startX : startX - w;

                        cx.fillStyle = color;
                        cx.fillRect(x, y, w, h);
                        cx.fillStyle = '#bdc3c7';
                        cx.fillRect(x, y, w, 5);
                        cx.fillStyle = 'rgba(255, 255, 255, 0.3)';

                        if (Math.random() > 0.5) {
                            cx.fillRect(x + 5, y + 10, w - 10, h - 15);
                        } else {
                            for (let wy = y + 10; wy < y + h - 5; wy += 10) {
                                cx.fillRect(x + 5, wy, 5, 5);
                                if (w > 20) cx.fillRect(x + 15, wy, 5, 5);
                            }
                        }
                        y += h + 2;
                    }
                };
                drawBuildings(0, true);
                drawBuildings(c.width, false);
            } else {
                const treeColor = '#55efc4'; /* Pastel Green */
                const shadowColor = 'rgba(0,0,0,0.1)';
                const treeSpacing = 30;
                const drawTrees = (startX, isLeft) => {
                    for (let y = 0; y < c.height; y += treeSpacing) {
                        const centerX = isLeft ? 20 : c.width - 20;
                        const shadowX = isLeft ? 30 : c.width - 30;
                        cx.fillStyle = shadowColor;
                        cx.beginPath();
                        cx.arc(shadowX, y + 5, 45, 0, Math.PI * 2);
                        cx.fill();
                        cx.fillStyle = treeColor;
                        cx.beginPath();
                        cx.arc(centerX, y, 40, 0, Math.PI * 2);
                        cx.fill();
                    }
                };
                drawTrees(0, true);
                drawTrees(0, false);
            }

            const gradient = cx.createLinearGradient(0, 0, c.width, 0);
            gradient.addColorStop(0, 'rgba(0,0,0,0.4)');
            gradient.addColorStop(0.2, 'rgba(0,0,0,0)');
            gradient.addColorStop(0.8, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
            cx.fillStyle = gradient;
            cx.fillRect(0, 0, c.width, c.height);
            return c;
        }

        // --- „ÇØ„É©„ÇπÂÆöÁæ© ---
        class Entity {
            constructor(x, y, radius, color) {
                this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.markedForDeletion = false;
            }
        }

        class Player extends Entity {
            constructor() {
                super(canvas.width / 2, canvas.height - 100, 20, '#81ecec'); /* Pastel Water Blue */
                this.shootInterval = 6;
                this.powerLevel = isPracticeMode ? practiceSettings.playerPower : 1;
                this.cloneCount = 0;
                this.hasClones = false; // Add this property
                mouseX = this.x;
                this.image = new Image();
                this.image.src = 'player_fixed.png';
                this.processedImage = null;
            }
            update() {
                this.x += (mouseX - this.x) * CONFIG.playerSpeed;
                if (this.x < this.radius) this.x = this.radius;
                if (this.x > canvas.width - this.radius) this.x = canvas.width - this.radius;
                if (isFiring && frameCount % this.shootInterval === 0) this.shoot();

                if (this.powerLevel >= 3) this.color = '#a29bfe'; /* Pastel Purple */
                else if (this.powerLevel > 1) this.color = '#74b9ff';
            }
            getClonePositions() {
                const positions = [];
                if (this.cloneCount >= 2) {
                    if (this.cloneCount === 2) {
                        positions.push({ x: -40, y: 40 }); positions.push({ x: 40, y: 40 });
                    } else {
                        positions.push({ x: -40, y: -40 }); positions.push({ x: 40, y: -40 });
                        positions.push({ x: -40, y: 40 }); positions.push({ x: 40, y: 40 });
                    }
                }
                if (this.cloneCount >= 6) {
                    const extraCount = Math.min(this.cloneCount, 9) - 4;
                    for (let i = 0; i < extraCount / 2; i++) {
                        const offsetX = 80 + (i * 40);
                        positions.push({ x: -offsetX, y: 0 }); positions.push({ x: offsetX, y: 0 });
                    }
                }
                return positions;
            }
            draw() {
                ctx.save();
                this.drawBody(this.x, this.y);
                if (this.hasClones) {
                    const clones = this.getClonePositions();
                    clones.forEach(pos => this.drawBody(this.x + pos.x, this.y + pos.y, true));
                }
                ctx.restore();
            }
            drawBody(x, y, isClone = false) {
                ctx.save();
                ctx.translate(x, y);
                if (isClone) ctx.scale(0.7, 0.7);

                // 1.2ÂÄç„Å´Êã°Â§ß (ÂÖÉ„ÅÆÁîªÂÉè48x48 -> 57.6x57.6)
                ctx.scale(1.2, 1.2);

                // ÁîªÂÉèÊèèÁîª (48x48) - ‰∏≠ÂøÉÂêà„Çè„Åõ
                if (this.image && this.image.complete) {
                    ctx.drawImage(this.image, -24, -24, 48, 48);
                } else {
                    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºàÁîªÂÉèË™≠„ÅøËæº„ÅøÂâçÔºâ
                    ctx.fillStyle = this.color;
                    ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
                }

                // Áô∫Â∞ÑÊôÇ„ÅÆ„Ç®„Éï„Çß„ÇØ„ÉàÔºàÂ§ßÁ†≤„ÅÆÂæå„ÇçÔºâ
                if (isFiring && frameCount % this.shootInterval < 3) {
                    ctx.fillStyle = '#f39c12';
                    // Â§ßÁ†≤„ÅÆ‰ΩçÁΩÆ„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥ (Â∑¶Âè≥20px, ‰∏ã22px -> scale„ÅßËá™ÂãïÁöÑ„Å´1.2ÂÄç„ÅÆ‰ΩçÁΩÆ„Å´„Å™„Çã)
                    // „Åü„Å†„Åó„ÄÅ‰ΩçÁΩÆË™øÊï¥„ÅåÂøÖË¶Å„Å™„Çâ„Åì„Åì„ÅßË°å„ÅÜ„ÄÇ
                    // 20px * 1.2 = 24px (ÁîªÈù¢‰∏ä)
                    // „Åì„Åì„Åß„ÅØscale„Åå„Åã„Åã„Å£„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅÂÖÉ„ÅÆÂ∫ßÊ®ôÁ≥ª(20px)„ÅßÊåáÂÆö„Åô„Çå„Å∞ÁîªÈù¢‰∏ä„Åß„ÅØ1.2ÂÄç„Å´„Å™„Çã
                    ctx.beginPath();
                    ctx.arc(-20, 22, 6, 0, Math.PI * 2);
                    ctx.arc(20, 22, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
            shoot() {
                const damage = this.powerLevel;
                let color = '#f1c40f';
                if (this.powerLevel === 1.5) color = '#8e44ad';
                if (this.powerLevel >= 3) color = '#e74c3c';

                // Â§ßÁ†≤„ÅÆ‰ΩçÁΩÆ„Å´Âêà„Çè„Åõ„Å¶Áô∫Â∞Ñ‰ΩçÁΩÆË™øÊï¥ (Â∑¶Âè≥20px -> 1.2ÂÄç„Åß24px)
                bullets.push(new Bullet(this.x - 24, this.y, -CONFIG.bulletSpeed, color, damage));
                bullets.push(new Bullet(this.x + 24, this.y, -CONFIG.bulletSpeed, color, damage));

                if (this.hasClones) {
                    const clones = this.getClonePositions();
                    clones.forEach(pos => {
                        // „ÇØ„É≠„Éº„É≥„ÅØ0.7ÂÄç„Å™„ÅÆ„Åß„ÄÅÁô∫Â∞Ñ‰ΩçÁΩÆ„ÇÇ0.7ÂÄç (24 * 0.7 = 16.8 -> 17)
                        bullets.push(new Bullet(this.x + pos.x - 17, this.y + pos.y, -CONFIG.bulletSpeed, color, damage));
                        bullets.push(new Bullet(this.x + pos.x + 17, this.y + pos.y, -CONFIG.bulletSpeed, color, damage));
                    });
                }
                sound.playShoot();
            }
        }

        class Enemy extends Entity {
            constructor(forceSpecial = false) {
                const radius = 22;
                const sideMargin = 90;
                const safeWidth = canvas.width - (sideMargin * 2);
                const x = Math.random() * safeWidth + sideMargin;
                super(x, -50, radius, '#fd79a8'); /* Pastel Pink */
                this.speedY = Math.random() * (CONFIG.enemySpeedMax - CONFIG.enemySpeedMin) + CONFIG.enemySpeedMin;
                this.wobblePhase = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.05;
                this.wobbleAmount = 1;

                if (isPracticeMode) {
                    this.maxHp = practiceSettings.enemyHp;
                } else {
                    this.maxHp = 1 * enemyHpMultiplier;
                }
                this.hp = this.maxHp;

                this.isRare = false;
                this.isSpecial = false;

                if (isPracticeMode) {
                    if (practiceSettings.items && forceSpecial) {
                        this.isSpecial = true;
                        this.color = '#ffffff';
                        this.speedY = 0.5;
                        this.maxHp *= 3;
                        this.hp = this.maxHp;
                    }
                }
                else {
                    if (stageLevel >= 4 && (forceSpecial || Math.random() < 0.001)) {
                        this.isSpecial = true;
                        this.color = '#ffffff';
                        this.speedY = 0.5;
                        this.maxHp *= 3;
                        this.hp = this.maxHp;
                    }
                    else if (stageLevel >= 3 && Math.random() < 0.01) {
                        this.isRare = true;
                        this.color = '#f1c40f';
                        this.speedY = 1.0;
                        this.maxHp *= 3;
                        this.hp = this.maxHp;
                    } else {
                        this.type = Math.random() > 0.5 ? 0 : 1;
                        if (this.type === 1) {
                            this.color = '#55efc4'; /* Pastel Green */
                            this.speedY += 0.3;
                        }
                    }
                }
            }
            update() {
                this.y += this.speedY;
                this.x += Math.sin(frameCount * this.wobbleSpeed + this.wobblePhase) * this.wobbleAmount;
                if (this.y > canvas.height + 50) this.markedForDeletion = true;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10; ctx.shadowOffsetY = 15;

                if (this.isSpecial) {
                    const alpha = 0.5 + Math.sin(frameCount * 0.2) * 0.5;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fillStyle = '#b2bec3';
                } else if (this.isRare) {
                    ctx.fillStyle = '#ffeaa7'; /* Pastel Yellow */
                } else {
                    ctx.fillStyle = this.type === 0 ? '#fd79a8' : '#55efc4';
                }

                ctx.beginPath(); ctx.roundRect(-16, -10, 32, 28, 5); ctx.fill();
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(0, -12, 20, Math.PI, 0); ctx.lineTo(20, -5); ctx.lineTo(-20, -5); ctx.fill();
                ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(-20, -5, 40, 5);
                ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(-8, -10, 5, 0, Math.PI * 2); ctx.arc(8, -10, 5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(-8, -10, 2, 0, Math.PI * 2); ctx.arc(8, -10, 2, 0, Math.PI * 2); ctx.fill(); /* Pupil */

                /* Eyeball Logic Marker - Used for explosion logic */
                this.eyeL = { x: -8, y: -10 };
                this.eyeR = { x: 8, y: -10 };

                ctx.fillStyle = '#636e72'; ctx.fillRect(-5, 5, 10, 25);

                if (this.hp < this.maxHp) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            }
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.markedForDeletion = true;
                    if (this.isSpecial) {
                        if (player.cloneCount >= 9) {
                            items.push(new Item(this.x, this.y, 'super_power'));
                        } else {
                            const r = Math.random();
                            if (r < 0.5) items.push(new Item(this.x, this.y, 'super_power'));
                            else items.push(new Item(this.x, this.y, 'extra_clone'));
                        }
                    } else if (this.isRare) {
                        items.push(new Item(this.x, this.y, 'clone'));
                    }
                    return true;
                }
                return false;
            }
        }

        class Boss extends Entity {
            constructor() {
                super(canvas.width / 2, -150, 70, '#a29bfe'); /* Pastel Purple */
                this.speedY = 0.3;
                this.maxHp = CONFIG.baseBossHp * enemyHpMultiplier;
                this.hp = this.maxHp;
                this.scale = 3;
            }
            update() {
                this.y += this.speedY;

                // „Éú„ÇπÊíÉÁ†¥ÊôÇ„ÅÆÁâπÂà•Âá¶ÁêÜ
                if (this.hp <= 0 && !isWarping) {
                    startWarpSequence();
                    this.markedForDeletion = true; // „Éú„Çπ„ÅØÊ∂à„Åô
                    // „Éú„ÇπÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàÔºàcreateExplosion„Å™„Å©„ÅØstartWarpSequenceÂÜÖ„ÅßÂëº„Å∂„Åã„ÄÅ„Åì„Åì„ÅßÂëº„Å∂Ôºâ
                    createExplosion(this.x, this.y, this.color, true, true);
                    sound.playExplosion();
                    score += CONFIG.bossScore;
                    bossActive = false;
                } else if (this.y > canvas.height + 150) {
                    this.markedForDeletion = true;
                    bossActive = false;
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                const barWidth = 120; const barHeight = 15; const hpPercent = this.hp / this.maxHp;
                ctx.fillStyle = '#333'; ctx.fillRect(-barWidth / 2, -110, barWidth, barHeight);
                ctx.fillStyle = '#e74c3c'; ctx.fillRect(-barWidth / 2, -110, barWidth * hpPercent, barHeight);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(-barWidth / 2, -110, barWidth, barHeight);
                ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 4; ctx.fillText(Math.ceil(this.hp), 0, -120);

                ctx.scale(this.scale, this.scale);
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetY = 5;
                ctx.fillStyle = '#5b2c6f'; ctx.beginPath(); ctx.roundRect(-16, -10, 32, 28, 5); ctx.fill();
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, -12, 20, Math.PI, 0); ctx.lineTo(20, -5); ctx.lineTo(-20, -5); ctx.fill();
                ctx.fillStyle = '#f39c12'; ctx.fillRect(-20, -5, 40, 5);
                ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(5, -12); ctx.lineTo(-5, -12); ctx.fill();
                ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(-8, -10, 6, 0, Math.PI * 2); ctx.arc(8, -10, 6, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(-8, -10, 2, 0, Math.PI * 2); ctx.arc(8, -10, 2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#2c3e50'; ctx.fillRect(-8, 5, 16, 30);
                ctx.restore();
            }
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0; this.markedForDeletion = true;
                    return true;
                }
                return false;
            }
        }

        class Bullet extends Entity {
            constructor(x, y, speedY, color, damage) {
                super(x, y, 4, color);
                this.speedY = speedY; this.width = 6; this.height = 15; this.damage = damage;
            }
            update() {
                this.y += this.speedY;
                if (this.y < -50 || this.y > canvas.height + 50) this.markedForDeletion = true;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 10;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();
            }
        }

        class Item extends Entity {
            constructor(x, y, type) {
                super(x, y, 20, '#fff');
                this.type = type; this.speedY = 1.5;
            }
            update() {
                this.y += this.speedY;
                if (this.y > canvas.height + 50) this.markedForDeletion = true;
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3;
                if (this.type === 'super_power') {
                    ctx.shadowBlur = 10; ctx.shadowColor = '#9b59b6'; ctx.strokeStyle = '#9b59b6';
                }
                ctx.stroke();
                if (this.type === 'powerup') {
                    ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('P', 0, 1);
                } else if (this.type === 'clone') {
                    ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(10, 5); ctx.lineTo(-10, 5); ctx.fill();
                } else if (this.type === 'super_power') {
                    ctx.fillStyle = '#9b59b6'; ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(12, 6); ctx.lineTo(-12, 6); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'extra_clone') {
                    ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(10, 0); ctx.lineTo(0, 10); ctx.lineTo(-10, 0); ctx.fill();
                }
                ctx.restore();
            }
        }

        class Particle extends Entity {
            constructor(x, y, color, type = 'blast') {
                const size = type === 'blast' ? Math.random() * 4 + 2 : Math.random() * 2 + 1;
                super(x, y, size, color);
                this.type = type;

                // Eyeball specific
                if (type === 'eyeball') {
                    this.radius = 5;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed - 1; // Less upward pop
                    this.decay = 0.06; // Fade out quickly (2x)
                    this.life = 60; // Shorter life
                    this.gravity = 0.1; // Less gravity
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.1; // Slower rotation
                }
                else if (type === 'blast') {
                    // Êó¢Â≠ò„ÅÆ‰∏ä„Å∏Âêπ„ÅçÈ£õ„Å∂
                    const angle = (Math.random() * 0.8 + 1.1) * Math.PI;
                    const speed = (Math.random() * 12 + 8) * 0.5;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.decay = (Math.random() * 0.02 + 0.01) * 0.5;
                } else {
                    // Êñ∞Ë¶è„ÅÆ‰∏ã„Å∏ËêΩ„Å°„ÇãÁ¥∞„Åã„ÅÑÁ†¥Áâá
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 5 + 2) * 0.5;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.decay = (Math.random() * 0.05 + 0.02) * 0.5;
                }

                this.alpha = 1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.25;
                this.shapeType = Math.random() > 0.5 ? 0 : 1;
            }
            update() {
                if (this.type === 'eyeball') {
                    this.vy += this.gravity;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.9;
                    this.vy *= 0.9;
                    this.rotation += this.rotationSpeed;

                    this.alpha -= this.decay;
                    if (this.alpha <= 0) this.markedForDeletion = true;
                }
                else {
                    this.vx *= CONFIG.drag;
                    this.vy *= CONFIG.drag;

                    if (this.type === 'blast') {
                        this.vy -= CONFIG.gravity;
                    } else {
                        this.vy += CONFIG.gravity;
                    }

                    this.x += this.vx;
                    this.y += this.vy;
                    this.alpha -= this.decay;
                    this.rotation += this.rotationSpeed;
                    if (this.alpha <= 0) this.markedForDeletion = true;
                }

            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);

                if (this.type === 'eyeball') {
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath(); ctx.arc(this.radius * 0.4, 0, this.radius * 0.4, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color;
                    if (this.shapeType === 0) ctx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
                    else { ctx.beginPath(); ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, this.radius); ctx.lineTo(-this.radius, this.radius); ctx.fill(); }
                }
                ctx.restore();
            }
        }

        class WarpParticle {
            constructor(isExplosion = false, startX, startY) {
                if (isExplosion) {
                    // ÊïµÊíÉÁ†¥ÊôÇ„ÅÆÁàÜÁô∫Áî®
                    this.x = startX;
                    this.y = startY;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 3;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.size = Math.random() * 8 + 4; // Â§ß„Åç„ÇÅ
                    this.decay = 0.05;
                    this.life = 100;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.2;

                    // ÁàÜÁô∫ÊôÇ„ÅØÈªÑËâ≤„Å®Ê∞¥Ëâ≤„ÅÆ„Åø
                    const explosionColors = ['#ffeaa7', '#81ecec']; // Yellow, Light Blue
                    this.color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                } else {
                    // „ÉØ„Éº„ÉóÊºîÂá∫Áî®Ôºà‰∏ä„Åã„Çâ‰∏ã„Å∏ÊµÅ„Çå„ÇãÔºâ
                    this.x = Math.random() * canvas.width;
                    this.y = -20; // ÁîªÈù¢‰∏äÈÉ®„Åã„Çâ
                    const angle = Math.PI / 2 + (Math.random() - 0.5) * 0.2; // „Åª„ÅºÁúü‰∏ã„Å∏
                    const speed = Math.random() * 15 + 10; // È´òÈÄü
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.size = Math.random() * 6 + 3;
                    this.decay = 0.02; // „ÉØ„Éº„Éó‰∏≠„ÅØÊ∂à„Åà„Å´„Åè„ÅÑ
                    this.life = 100;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.1;

                    // „ÉØ„Éº„ÉóÊôÇ„ÅØ„Ç´„É©„Éï„É´„Å´
                    const warpColors = ['#81ecec', '#fab1a0', '#ffeaa7', '#a29bfe', '#fd79a8'];
                    this.color = warpColors[Math.floor(Math.random() * warpColors.length)];
                }
            }
            update() {
                if (this.decay === 0.05) { // ÁàÜÁô∫Áî®
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.2; // ÈáçÂäõ
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                    this.life -= 4; // Ê∂à„Åà„ÇãÈÄüÂ∫¶
                } else { // „ÉØ„Éº„ÉóÁî®
                    this.x += this.vx;
                    this.y += this.vy;
                    // this.size *= 0.95; // „ÉØ„Éº„Éó‰∏≠„ÅØ„Çµ„Ç§„Ç∫Â§â„Åà„Åö
                    // this.life -= 2; // „ÉØ„Éº„Éó‰∏≠„ÅØÊ∂à„Åà„Å´„Åè„ÅÑ
                }
                this.rotation += this.rotationSpeed;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life / 100);
                // ÊòüÂΩ¢„ÇíÊèèÁîª (‰∏≠ÂøÉÂü∫Ê∫ñ„ÅßÊèèÁîª„Åô„Çã„Åü„ÇÅ„Å´0,0)
                drawStar(0, 0, 5, this.size, this.size / 2);
                ctx.restore();
            }
        }

        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        function createExplosion(x, y, baseColor, isBoss = false, isEnemy = false) {
            sound.playExplosion();
            const count = isBoss ? CONFIG.particleCount * 4 : CONFIG.particleCount;
            const effectColor = isEnemy ? '#d63031' : baseColor;
            const debrisColor = isEnemy ? '#ff7675' : baseColor;

            // ‰∏ä„Å∏
            for (let i = 0; i < count; i++) particles.push(new Particle(x, y, effectColor, 'blast'));

            // ‰∏ã„Å∏
            const debrisCount = Math.floor(count * 0.8);
            for (let i = 0; i < debrisCount; i++) particles.push(new Particle(x, y, debrisColor, 'debris'));

            // ÁÅ´Ëä±Ôºà‰∏ä„Å∏Ôºâ
            for (let i = 0; i < (isBoss ? 40 : 10); i++) {
                particles.push(new Particle(x, y, '#fdcb6e', 'blast'));
                particles.push(new Particle(x, y, '#b2bec3', 'blast'));
            }

            if (isEnemy || isBoss) {
                particles.push(new Particle(x - 8, y - 10, null, 'eyeball'));
                particles.push(new Particle(x + 8, y - 10, null, 'eyeball'));

                // Êòü„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÅÆËøΩÂä† (3-4ÂÄã)
                const starCount = Math.floor(Math.random() * 2) + 3; // 3 or 4
                for (let k = 0; k < starCount; k++) {
                    // explosion„Éï„É©„Ç∞„Çítrue„Å´„Åó„Å¶ÁîüÊàê
                    warpParticles.push(new WarpParticle(true, x, y));
                }

                if (isBoss) {
                    for (let k = 0; k < 4; k++) particles.push(new Particle(x, y, null, 'eyeball'));
                    // „Éú„Çπ„Å™„ÇâÊòü„ÇÇÂ§ö„ÇÅ„Å´
                    for (let k = 0; k < 8; k++) warpParticles.push(new WarpParticle(true, x, y));
                }
            }
        }

        // --- „É°„Ç§„É≥„É´„Éº„Éó ---
        function drawBackground() {
            let currentBg;
            if (isPracticeMode) {
                if (practiceSettings.stage === 'road') currentBg = bgRoadCanvas;
                else if (practiceSettings.stage === 'city') currentBg = bgCityCanvas;
                else currentBg = bgDirtCanvas;
            }
            else {
                if (stageLevel >= 4) currentBg = bgCityCanvas;
                else if (stageLevel > 1) currentBg = bgRoadCanvas;
                else currentBg = bgDirtCanvas;
            }

            if (!currentBg) return;

            const pattern = ctx.createPattern(currentBg, 'repeat');
            ctx.fillStyle = pattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function checkCollision(circle, rect) {
            if (!circle || !rect) return false;
            const dx = circle.x - rect.x;
            const dy = circle.y - rect.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < circle.radius + rect.radius;
        }

        function spawnEnemies() {
            if (bossActive || isWarping) return;

            // „Éú„Çπ„Çπ„Éù„Éº„É≥„É≠„Ç∏„ÉÉ„ÇØÊõ¥Êñ∞
            if (!bossSpawned && !isPracticeMode) {
                if (score >= nextBossScore) {
                    bossSpawned = true;
                    bossActive = true;
                    // Ë≠¶ÂëäÊºîÂá∫ÔºàÂøÖË¶Å„Å™„ÇâÔºâ
                    setTimeout(() => {
                        boss = new Boss();
                        enemies.push(boss); // Add boss to enemies array for collision detection
                    }, 2000); // 2ÁßíÂæå„Å´„Éú„ÇπÂá∫Áèæ
                    return; // „Éú„ÇπÂá∫ÁèæÊ∫ñÂÇô‰∏≠„ÅØÈõëÈ≠öÊïµ„Çí„Çπ„Éù„Éº„É≥„Åï„Åõ„Å™„ÅÑ
                }
            }

            let currentSpawnRate = CONFIG.spawnRate;
            if (score > 1000) currentSpawnRate = 8;
            if (score > 3000) currentSpawnRate = 5;

            if (frameCount % currentSpawnRate === 0) {
                enemySpawnCounter++;
                let forceSpecial = false;

                if (isPracticeMode && practiceSettings.items) {
                    if (enemySpawnCounter % 200 === 0) forceSpecial = true;
                }
                else if (!isPracticeMode) {
                    if (stageLevel >= 4 && enemySpawnCounter % 200 === 0) forceSpecial = true;
                }

                enemies.push(new Enemy(forceSpecial));
            }
        }

        function gameOver() {
            gameRunning = false;
            sound.stopBGM(); // BGMÂÅúÊ≠¢
            finalScoreDisplay.innerText = score;
            finalStageDisplay.innerText = isPracticeMode ? '-' : stageLevel;
            gameOverScreen.classList.remove('hidden');
            quitPracticeButton.classList.add('hidden');
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function togglePause() {
            if (!gameRunning && !isPaused) return;
            isPaused = !isPaused;
            if (isPaused) {
                pauseScreen.classList.remove('hidden');
                sound.stopBGM(); // „Éù„Éº„Ç∫‰∏≠„ÅØÂÅúÊ≠¢
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
            else {
                pauseScreen.classList.add('hidden');
                sound.playBGM(); // ÂÜçÈñã
                animate();
            }
        }

        function updatePowerDisplay() {
            let val = player.powerLevel;
            if (Number.isInteger(val)) powerValueDisplay.innerText = val;
            else powerValueDisplay.innerText = val.toFixed(1);
        }

        function updateStageDisplay() {
            if (isPracticeMode) {
                const map = { 'forest': 'Ê£ÆÊûó', 'road': 'ÈÅìË∑Ø', 'city': 'Â∏ÇË°óÂú∞' };
                stageDisplay.innerText = map[practiceSettings.stage] + " (Á∑¥Áøí)";
            } else {
                stageDisplay.innerText = stageLevel;
            }
        }

        function startWarpSequence() {
            isWarping = true;
            warpTimer = 0;
            warpParticles = [];
            // ËÉåÊôØ„ÇÑÊïµ„ÅÆÈÄ≤Ë°å„ÇíÊ≠¢„ÇÅ„Çã„Å™„Å©„ÅÆ„Éï„É©„Ç∞ÁÆ°ÁêÜ„ÅåÂøÖË¶Å„Å™„Çâ„Åì„Åì„Åß
            bullets = []; // Âºæ„ÇíÊ∂à„Åô
            items = []; // „Ç¢„Ç§„ÉÜ„É†„ÇÇÊ∂à„Åô
            enemies = []; // ÊÆã„Å£„Å¶„ÅÑ„ÇãÊïµ„ÇÇÊ∂à„Åô
            sound.stopBGM(); // BGM„Çí‰∏ÄÊôÇÂÅúÊ≠¢
        }

        function initGame(mode) { /* ÂÆüÈöõ„ÅÆ„Ç≤„Éº„É†ÈñãÂßãÂá¶ÁêÜ */
            gameMode = mode;
            isPracticeMode = (mode === 'practice');
            score = 0;
            stageLevel = 1;
            player = new Player(); // Re-initialize player to reset powerLevel, cloneCount etc.
            player.powerLevel = isPracticeMode ? practiceSettings.playerPower : 1;
            player.hasClones = false; // Ensure this is reset
            enemies = [];
            bullets = [];
            particles = [];
            items = [];
            enemyHpMultiplier = 1;
            bossSpawned = false;
            bossActive = false;
            stageTimer = 0;
            isWarping = false; // „É™„Çª„ÉÉ„Éà
            warpParticles = [];
            frameCount = 0; // Reset frame count

            if (isPracticeMode) {
                // In practice mode, stageLevel is just a display string, not a progression number
                // The actual stage type is handled by practiceSettings.stage
                // CONFIG.spawnRate might be adjusted based on practice settings if needed
            } else {
                CONFIG.spawnRate = 10; // Reset to default for normal mode
            }

            scoreDisplay.textContent = score;
            updateStageDisplay(); // Call to update based on stageLevel or practiceSettings
            updatePowerDisplay(); // Call to update based on player.powerLevel

            gameRunning = true;
            isPaused = false;
            if (animationId) cancelAnimationFrame(animationId); // Clear any previous animation loop
            animationId = requestAnimationFrame(animate);

            sound.init();
            sound.playBGM();
        }

        function triggerStartSequence(mode) {
            const overlay = document.getElementById('start-sequence-overlay');
            const countdownText = document.getElementById('start-countdown');
            overlay.classList.remove('hidden');
            startScreen.classList.add('hidden');
            practiceConfigScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');

            let count = 3;
            countdownText.innerText = count;

            // Èü≥„ÇíÈ≥¥„Çâ„ÅôÊ∫ñÂÇôÔºà„É¶„Éº„Ç∂„ÉºÊìç‰ΩúÁõ¥Âæå„Å™„ÅÆ„ÅßOKÔºâ
            sound.init();

            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.innerText = count;
                    sound.playCountdown(false); // 3, 2, 1 Sound
                } else if (count === 0) {
                    countdownText.innerText = "GO!";
                    sound.playCountdown(true); // GO! Sound
                } else {
                    clearInterval(timer);
                    setTimeout(() => {
                        overlay.classList.add('hidden');
                        initGame(mode);
                    }, 500);
                }
            }, 1000);
        }

        function startGame(mode) {
            // Áõ¥Êé•initGame„ÇíÂëº„Å∞„Åö„ÄÅ„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈñãÂßã
            triggerStartSequence(mode);
        }

        practiceButton.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            practiceConfigScreen.classList.remove('hidden');
        });

        backToTitleBtn.addEventListener('click', () => {
            practiceConfigScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });

        quitPracticeButton.addEventListener('click', () => {
            gameRunning = false;
            isPaused = false;
            sound.stopBGM(); // BGMÂÅúÊ≠¢
            quitPracticeButton.classList.add('hidden');
            startScreen.classList.remove('hidden'); // Go back to start screen
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        });

        confStageBtn.addEventListener('click', () => {
            const stages = ['forest', 'road', 'city'];
            let current = practiceSettings.stage;
            let nextIndex = (stages.indexOf(current) + 1) % stages.length;
            practiceSettings.stage = stages[nextIndex];
            const map = { 'forest': 'Ê£ÆÊûó', 'road': 'ÈÅìË∑Ø', 'city': 'Â∏ÇË°óÂú∞' };
            confStageBtn.innerText = map[practiceSettings.stage];
        });

        confItemBtn.addEventListener('click', () => {
            practiceSettings.items = !practiceSettings.items;
            confItemBtn.innerText = practiceSettings.items ? '„ÅÇ„Çä' : '„Å™„Åó';
        });

        confEnemyHpInput.addEventListener('change', (e) => {
            let val = parseInt(e.target.value);
            if (isNaN(val) || val < 1) val = 1;
            practiceSettings.enemyHp = val;
        });

        confPlayerPowerInput.addEventListener('change', (e) => {
            let val = parseFloat(e.target.value);
            if (isNaN(val) || val < 1) val = 1;
            practiceSettings.playerPower = val;
        });

        startPracticeBtn.addEventListener('click', () => {
            startGame('practice');
        });

        startButton.addEventListener('click', () => { startGame('normal'); });
        restartButton.addEventListener('click', () => { startGame(gameMode); }); // Use gameMode to restart in correct mode
        pauseButton.addEventListener('click', togglePause);
        resumeButton.addEventListener('click', togglePause);
        muteButton.addEventListener('click', () => { sound.toggleMute(); });

        function animate() {
            if (!gameRunning) return;

            // --- „ÉØ„Éº„ÉóÊºîÂá∫‰∏≠ ---
            if (isWarping) {
                ctx.fillStyle = 'rgba(255, 234, 167, 0.3)'; // ÊÆãÂÉèÂäπÊûú
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (frameCount % 4 === 0) {
                    // ÂØÜÂ∫¶5ÂÄç„Åè„Çâ„ÅÑ: ‰∏ÄÂ∫¶„Å´Â§ßÈáèÁîüÊàê
                    for (let i = 0; i < 8; i++) warpParticles.push(new WarpParticle(false));
                }

                warpParticles.forEach((p, index) => {
                    p.update();
                    p.draw();
                    // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÊ∂à„ÅôÔºà„ÉØ„Éº„ÉóÁî®Ôºâ
                    if (p.y > canvas.height + 50 || p.life <= 0) warpParticles.splice(index, 1);
                });

                warpTimer++;
                if (warpTimer > 180) { // 3ÁßíÂæå
                    isWarping = false;
                    warpParticles = [];
                    // Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å∏
                    stageLevel++;
                    updateStageDisplay();
                    enemyHpMultiplier += 0.5;
                    bossSpawned = false;
                    bossActive = false;
                    nextBossScore = CONFIG.bossScoreThreshold * stageLevel; // Update next boss score
                    stageTimer = 0; // Reset stage timer

                    // ËÉåÊôØËâ≤„ÇíÂ∞ë„ÅóÂ§â„Åà„Çã„Å™„Å©„Åó„Å¶„ÇÇ„Çà„ÅÑ
                    sound.playBGM(); // BGMÂÜçÈñã
                }

                // „Éó„É¨„Ç§„É§„Éº„ÅÆÊèèÁîª„Å†„ÅëÊÆã„ÅôÔºàÊìç‰Ωú‰∏çËÉΩ„Åß„ÇÇË°®Á§∫„ÅØÁ∂ö„Åë„Çã„Å®„ÅãÔºâ
                player.draw();

                animationId = requestAnimationFrame(animate);
                frameCount++;
                return;
            }

            if (isPaused) {
                animationId = requestAnimationFrame(animate); // Keep requesting frames to check for unpause
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            // warpParticles (Explosion stars) need to be drawn during normal gameplay too
            warpParticles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.life <= 0) warpParticles.splice(index, 1);
            });

            player.update();
            player.draw();

            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                item.update();
                item.draw();
                if (checkCollision(player, item)) {
                    item.markedForDeletion = true;
                    sound.playPowerUp();
                    let powerChanged = false;

                    if (item.type === 'powerup') {
                        if (player.powerLevel < 3) { player.powerLevel = 1.5; powerChanged = true; }
                    } else if (item.type === 'clone') {
                        if (player.cloneCount < 2) { player.cloneCount = 2; player.hasClones = true; }
                    } else if (item.type === 'super_power') {
                        if (player.powerLevel < 3) player.powerLevel = 3;
                        else player.powerLevel *= 1.3;
                        powerChanged = true;
                    } else if (item.type === 'extra_clone') {
                        if (player.cloneCount < 9) {
                            player.cloneCount = Math.min(player.cloneCount + 2, 9);
                            player.hasClones = true;
                        }
                    }
                    if (powerChanged) updatePowerDisplay();
                }
                if (item.markedForDeletion) items.splice(i, 1);
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                let bullet = bullets[i];
                bullet.update();
                bullet.draw();
                if (bullet.markedForDeletion) bullets.splice(i, 1);
            }

            spawnEnemies();

            if (bossActive && boss) {
                boss.update();
                boss.draw();
                if (checkCollision(player, boss)) {
                    createExplosion(player.x, player.y, player.color);
                    gameOver();
                }
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (!boss) break;
                    let bullet = bullets[j];
                    if (checkCollision(boss, bullet)) {
                        bullet.markedForDeletion = true;
                        const isDead = boss.takeDamage(bullet.damage);
                        createExplosion(bullet.x, bullet.y - 10, '#f1c40f');
                        if (isDead) {
                            createExplosion(boss.x, boss.y, boss.color, true, true);
                            score += CONFIG.bossScore;
                            scoreDisplay.innerText = score;
                            if (stageLevel === 2) items.push(new Item(boss.x, boss.y, 'powerup'));
                            stageLevel++;
                            updateStageDisplay();
                            enemyHpMultiplier *= 2;
                            boss = null;
                            bossActive = false;
                            break;
                        }
                    }
                }
                if (boss && boss.markedForDeletion) { boss = null; bossActive = false; }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                enemy.update();
                enemy.draw();

                if (checkCollision(player, enemy)) {
                    if (player.hasClones && player.cloneCount > 0) {
                        player.cloneCount -= 2;
                        if (player.cloneCount <= 0) { player.cloneCount = 0; player.hasClones = false; }
                        createExplosion(enemy.x, enemy.y, enemy.color, false, true);
                        enemy.markedForDeletion = true;
                    } else {
                        createExplosion(player.x, player.y, player.color);
                        createExplosion(enemy.x, enemy.y, enemy.color, false, true);
                        gameOver();
                    }
                }

                for (let j = bullets.length - 1; j >= 0; j--) {
                    let bullet = bullets[j];
                    if (checkCollision(enemy, bullet)) {
                        bullet.markedForDeletion = true;
                        const isDead = enemy.takeDamage(bullet.damage);
                        if (isDead) {
                            createExplosion(enemy.x, enemy.y, enemy.color, false, true);
                            score += 100;
                            scoreDisplay.innerText = score;
                        } else {
                            createExplosion(bullet.x, bullet.y, '#fdcb6e');
                        }
                    }
                }
                if (enemy.markedForDeletion) enemies.splice(i, 1);
            }

            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.markedForDeletion) particles.splice(index, 1);
            });

            frameCount++;
            requestAnimationFrame(animate);
        }

        resize();
    </script>
</body>

</html>